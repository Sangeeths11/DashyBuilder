%LaTeX-Vorlage --------------------------------------Rev. 1.1

%Verfasser:

%David Schober
%Meienriedweg 15
%2556 Scheuren
%Student BSc Informationswissenschaften der FHGR
%isc_tz_z_21
%david.schober@stud.fhgr.ch

%Diese Vorlage steht unter der CC0-Lizenz. Das betrifft den Quelltext sowie die formalen Aspekte wie Gestaltung und Formatierung.
%Die Angaben zum Autor sind nur vorhanden, falls eine Quellenangabe trotzdem vorgeschrieben wird.
%Das ist auch der einzige Grund sie in der Vorlage aufzuführen und zu belassen.
%Sieht am fertigen Dokument sowieso niemand! :-)

%Die Probleme zwischen den Lizenzen für die Nutzung der Vorlage bzw. für die Nutzung der Inhalte ergeben sich insofern nicht, da für die Nutzerinnen der Vorlage die Inhalte irrelevant sind. Zugleich haben die Nutzerinnen der Inhalte die Vorlage nicht.


\documentclass[a4paper, 12pt]{scrartcl}

%Ab hier die zu ladenden Pakete
%------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath, amssymb, amstext}
\usepackage{nameref}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{fancyvrb}
\usepackage{framed}
\usepackage{pgfgantt}
\usepackage{listings}
\usepackage{float}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{pdflscape} % Für das Drehen der Seite im PDF
\usepackage[a4paper,margin=1in]{geometry}


\lstset{
  basicstyle=\ttfamily\footnotesize, % Kleinere Schriftgröße für den Code
  breaklines=true,
  frame=single,
  language=Python,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=4,
  captionpos=b
}

\definecolor{dukeblue}{rgb}{0.0, 0.0, 0.61}
%------------------------------------------------------------


%Ab hier für Schriftart und Schrift
%------------------------------------------------------------
\linespread{1.3} %Setze Zeilenabstand auf 1.3
\usepackage{mathptmx} %Lade Times ähnliche Schriftart
\usepackage{sectsty}
\allsectionsfont{\rmfamily\raggedright} %Setze Schriftart für alle Überschriften
\setkomafont{sectioning}{\normalcolor\bfseries}
\setkomafont{sectionentrypagenumber}{\normalcolor\mdseries}
%------------------------------------------------------------


%Ab hier für manuelle Seitengeometrie
%------------------------------------------------------------
\usepackage{geometry} %Lade Paket für manuelle Seitengeometrie
\geometry{a4paper, left=30mm, right=25mm, top=25mm, bottom=30mm}
\headsep = 22pt %Setze Abstände für die Seitenränder
%------------------------------------------------------------


%Ab hier für Kopf- und Fusszeile
%------------------------------------------------------------
\usepackage{fancyhdr} %Lade Paket für Kopf- und Fusszeile
\renewcommand{\headrulewidth}{0pt} % Keine Linie unter Kopfzeile
\renewcommand{\footrulewidth}{0.5pt} %Linie unter Fusszeile
\pagestyle{fancy} %Definiere Stil der Kopf- und Fusszeile
\lhead{\footnotesize{}} %Leer --> wird nicht angezeigt, bis manueller aufruf
\rhead{\footnotesize{}} %Leer --> wird nicht angezeigt, bis manueller aufruf
\cfoot{} %Leer --> wird nicht angezeigt, bis manueller aufruf
%------------------------------------------------------------


%Ab hier für Biblatex
%------------------------------------------------------------
\usepackage[style=apa, citetracker=true, maxcitenames=1, backend=biber]{biblatex}

\DeclareLanguageMapping{german}{german-apa}

\usepackage[babel, german=quotes]{csquotes} 

\AtEveryCitekey{%
	\ifciteseen{}{\defcounter{maxnames}{6}\clearfield{namehash}}}


\addbibresource{literatur.bib}
%-------------------------------------------------------------


%Ab hier sind neu definierte Kommandos
%-------------------------------------------------------------
%Dieses Komando übergibt das selbe "Sektionslabel"(gültig für \section{xxx}, \subsection{xxx} usw.) an drei verschiedene Referenzkommandos: 1. Gliederungsebene, 2. Überschrift, 3. Seitenzahl im Dokument.
\newcommand{\rtpref}[1]{Punkt~\ref{#1} \nameref{#1} ab 			Seite~\pageref{#1}}
%Verwendug: \rtpref{"Sektionslabel"nach Wahl} 
%Output: Punkt X.(X).(X) YYYYYYYYYYY ab Seite N(N) 
%z.B.----> Punkt 2.1.2 Profession ab Seite 2
\newcommand{\figref}[1]{Abbildung~\ref{#1} \nameref{#1} auf Seite~\pageref{#1}}

%Dieses Komando setzt den Text in den geschweiften Klammern fett und kursiv.
\newcommand{\texbfit}[1]{\textbf{\textit{#1}}}
%Verwendung: \texbfit{Fett und kursiv}
%Output: Fetter und kursiver Text.
%-------------------------------------------------------------


%Ab hier alles für Tabellen und Abbildungen
%-------------------------------------------------------------
\usepackage[justification=justified, singlelinecheck=false]{caption}
\usepackage{tabularx}
\usepackage{tabulary}
%-------------------------------------------------------------


%Ab hier für Links
%-------------------------------------------------------------
\usepackage[linktocpage=true, colorlinks=true, linkcolor=dukeblue, citecolor=dukeblue, filecolor=dukeblue, urlcolor=dukeblue]{hyperref}
%-------------------------------------------------------------


%Ab hier das Paket für Abkürzungen
%-------------------------------------------------------------
\usepackage[printonlyused, withpage]{acronym}

%Weitere Optionen, Befehle und Aufrufe siehe:
%https://www.namsu.de/Extra/pakete/Acronym.html
%-------------------------------------------------------------

\begin{document}

%Titelseite
%-------------------------------------------------------------
\begin{center}
	{\LARGE\textbf{Entwicklung eines dynamischen und modularen Dashboard-Layouts unter Verwendung moderner Frontend-Technologien}}\\
	\vspace{40mm} %Vertikaler Abstand 70mm
	{\large\textbf{Praktikumarbeit}}\\
	\vspace{40mm}

\begin{flushleft}
	\begin{tabbing}
		\hspace*{73mm}\= \kill
		Verfasser: \> Sangeeths Chandrakumar\\
		\> Riedenhaldenstrasse 26\\
		\> 8046 Zürich\\
		\> {sangeeths.chandrakumar@stud.fhgr.ch}\\
	\end{tabbing}
	
	\begin{tabbing}
		\hspace*{73mm}\= \kill
		Studiengang: \> BSc Computational and Data Science\\
		\hspace*{73mm}\= \kill
		Modul: \> Fachpraktikum (cds-902)\\
		\hspace*{73mm}\= \kill
		Praktikumsbetreuer: \> Dr. rer. nat Helena Jambor\\
	\end{tabbing}

    \begin{tabbing}
        \hspace*{73mm}\= \kill
        Praktikumsbetrieb: \> \parbox[t]{0.6\textwidth}{Institut für Data Analysis, Artificial Intelligence, \\ Visualization und Simulation (DAViS)}\\
        \hspace*{73mm}\= \kill
        Betreuer: \> Dr. rer. nat Michael Burch\\
    \end{tabbing}
 
	\begin{tabbing}
		\hspace*{73mm}\= \kill
		Bearbeitungszeitraum: \> 20. September 2024 bis  21. Januar 2024 \\
	\end{tabbing}
	
\end{flushleft}

\vspace{10mm}

\newcommand{\ausgeschriebenerMonat}[1]{%
    \ifcase#1\or Januar\or Februar\or März\or April\or Mai\or Juni\or Juli\or August\or September\or Oktober\or November\or Dezember\fi%
}

\newcommand{\datum}{%
    \textbf{Chur, \number\day.\ausgeschriebenerMonat{\month} \number\year}
}
\datum

\end{center}

\thispagestyle{empty} %Seite ohne Kopf- und Fusszeile
%-------------------------------------------------------------



%Abstract
%-------------------------------------------------------------
%\newpage
%\thispagestyle{empty}
%\thispagestyle{fancy}
%\lhead{\footnotesize{Text}}
%\rhead{\footnotesize{Text}}

%\begin{flushleft}
%\textbf{\Large\bigskip{Abstract}}


%\end{flushleft}
%-------------------------------------------------------------


%Inhalts- Abbildungs und Tabellenverzeichnis
%-------------------------------------------------------------
\newpage
\rfoot{\footnotesize \thepage} %Setze Sitenzahl in der Fusszeile rechts
\pagenumbering{Roman} %Verwende römische Zahlen
\setcounter{page}{1} %Beginne Seitennummerierung bei 1
\lfoot{\footnotesize Sangeeths Chandrakumar} %Setze Name in der Fusszeile links
\cfoot{\footnotesize Wissenschaftliches Arbeiten (cds-9031)}

\begin{flushleft}
\tableofcontents

\newpage
\cleardoublepage
\addcontentsline{toc}{section}{\listfigurename}
\listoffigures

%Tabelleverzeichnis
%\newpage
%\cleardoublepage
%\addcontentsline{toc}{section}{\listtablename}
%\listoftables 

\newpage
\cleardoublepage
\addcontentsline{toc}{section}{Abkürzungsverzeichnis}
\section*{Abkürzungsverzeichnis}
\begin{acronym}[z.B.]
\acro{DS}{Data Science}
\acro{CS}{Computational Science}
\acro{FE}{Frontend}
\acro{BE}{Backend}
\acro{Vue}{Vue.js}
\acro{Nuxt}{Nuxt.js}
\acro{Tailwind}{Tailwind CSS}
\acro{Flask}{Python Flask}
\acro{CSV}{Comma-separated values}
\end{acronym}

%Es gibt die kurze und die lange Form von \ac{zb} ...
%\ac{kde}\\
%\ac{kde}
%Beim zweiten Mal \ac{zb}

\end{flushleft}
%-------------------------------------------------------------



% Ab hier beginnt die Arbeit
%-------------------------------------------------------------
\newpage
\pagenumbering{arabic} %Verwende arabische Zahlen
\setcounter{page}{1} %Beginne Seitennummerierung bei 1


	%\begin{flushleft}
		
	\section{Einleitung}
	\label{sec:einleitung}

\subsection{Einführung in das Thema}
Die Entwicklung dynamischer und modularer Dashboard-Layouts ist ein zentraler Aspekt moderner Webanwendungen, insbesondere im Bereich \ac{DS} und \ac{CS}. Dashboards fungieren als wesentliche Schnittstelle zur Visualisierung und Analyse von Daten, was sie zu einem wichtigen Instrument für die Entscheidungsfindung in Unternehmen macht (\cite{Bach2022}). Ein effektives Dashboard-Design erfordert nicht nur eine ansprechende Benutzeroberfläche, sondern auch eine hohe Flexibilität und Modularität, um den vielfältigen Anforderungen der Benutzer gerecht zu werden.\\[1em] Aktuelle Studien zeigen, dass die Wahl der richtigen \ac{FE}-Technologien entscheidend für den Erfolg solcher Dashboards ist. So betonen \textcite{Raposo2022}, dass moderne JavaScript-Frameworks wie \ac{Vue} und React aufgrund ihrer Komponentenstruktur und Wiederverwendbarkeit besonders geeignet sind, um komplexe und dynamische Benutzeroberflächen zu gestalten. Diese Arbeit untersucht die Entwicklung eines dynamischen und modularen Dashboard-Layouts unter Verwendung moderner \ac{FE}-Technologien, insbesondere Vue 3, Nuxt 3 und \ac{Tailwind}, in Verbindung mit einem \ac{Flask} \ac{BE}.

\subsection{Problemstellung}
Die Entwicklung von Dashboards steht vor mehreren Herausforderungen, die sowohl technischer als auch benutzerorientierter Natur sind. Zum einen müssen Dashboards flexibel genug sein, um sich an verschiedene Datenquellen und Anwendungsszenarien anzupassen (\cite{Matheus2020}). Zum anderen sollten sie modular aufgebaut sein, um die Wartbarkeit und Erweiterbarkeit zu gewährleisten, was in grossen und langfristigen Projekten entscheidend ist (\cite{Behrisch2018}). Traditionelle \ac{FE}-Frameworks bieten zwar viele Funktionen, stossen jedoch oft an ihre Grenzen, wenn es darum geht, komplexe Anforderungen an Dynamik und Modularität zu erfüllen.\\[1em] Ein weiterer wichtiger Aspekt ist die Performance, insbesondere wenn Dashboards grosse Datenmengen in Echtzeit visualisieren müssen. Studien haben gezeigt, dass die Wahl der Architektur und der verwendeten Technologien massgeblich die Performance beeinflusst, was wiederum die Benutzererfahrung und die Effizienz der Datenanalyse direkt betrifft (\cite{Shneiderman2006}).

\subsection{Zielsetzung der Arbeit}
Das Hauptziel dieser Arbeit ist es, die Potenziale und Grenzen moderner \ac{FE}-Technologien bei der Entwicklung dynamischer und modularer Dashboard-Layouts zu untersuchen. Im Rahmen dieses Projekts wird ein flexibles Layout-Management-System entwickelt, das die Anordnung und Skalierung verschiedener Inhaltsboxen (Widgets) ermöglicht. Besonders Augenmerk wird dabei auf die Benutzerfreundlichkeit und Wartbarkeit des Dashboards gelegt. Daraus ergibt sich die zentrale Forschungsfrage dieser Arbeit:\\[1em]
\textit{„Wie können moderne Frontend-Technologien zur Entwicklung eines dynamischen und modularen Dashboard-Layouts eingesetzt werden, um die Benutzerfreundlichkeit und Wartbarkeit zu maximieren?“}\\[1em] Dieses Vorhaben adressiert eine wesentliche Lücke in der aktuellen Lage der Datenvisualisierung: die Balance zwischen technischer Komplexität und Nutzerfreundlichkeit. Während moderne Technologien wie Vue 3, Nuxt 3 und \ac{Tailwind} leistungsstarke Werkzeuge zur Entwicklung dynamischer und modularer Dashboards bieten, bleibt die Herausforderung bestehen, diese Technologien so zu nutzen, dass sie auch für Benutzer ohne tiefgehende Programmierkenntnisse zugänglich sind. Diese Arbeit verspricht, einen Weg zu ebnen, auf dem in naher Zukunft jeder, der Einblicke in seine Daten gewinnen möchte, dies unabhängig von seinen technischen Fähigkeiten erreichen kann. Dies würde nicht nur die Effizienz und Flexibilität von Dashboards steigern, sondern auch deren Einsatzmöglichkeiten erheblich erweitern.
\clearpage
	\section{Grundlagen}
	\label{sec:grundlagen}
 
\subsection{Plotly Dash}
Plotly Dash ist ein Framework zur Entwicklung interaktiver Webanwendungen, das speziell für den Einsatz in der Datenvisualisierung konzipiert wurde. Dash ermöglicht es, komplexe Datenanalysen und -visualisierungen durch die Kombination von Python-Skripten mit reaktiven Webtechnologien zu erstellen. \textcite{Dabbas2021} hebt hervor, dass sich Dash durch seine Fähigkeit auszeichnet, interaktive Dashboards zu erstellen, die direkt mit Datenquellen verbunden sind und eine Echtzeit-Aktualisierung der Daten ermöglichen.\\[1em] Das Framework basiert auf drei Haupttechnologien: Flask, React.js und Plotly.js. Flask fungiert als leichtgewichtiges Web-Framework, das die serverseitige Logik und die Anbindung an Datenquellen übernimmt. React.js, eine JavaScript-Bibliothek für die Entwicklung von Benutzeroberflächen, ermöglicht die Erstellung dynamischer und reaktiver UI-Komponenten. Plotly.js, die Visualisierungsbibliothek, bietet leistungsstarke Tools zur Erstellung interaktiver und ansprechender Diagramme und Graphen.\\[1em] Die Modularität von Dash ist ein entscheidender Vorteil, der es Entwicklern erlaubt, verschiedene Komponenten wie Diagramme, Slider und Dropdown-Menüs zu kombinieren und anzupassen. Diese Flexibilität macht Dash besonders geeignet für Anwendungen im Bereich der Datenanalyse, wo unterschiedliche Visualisierungstypen oft in einem einzigen Dashboard zusammengeführt werden müssen (\cite{Dabbas2021}).

\subsection{Vue.js und Nuxt.js}
\ac{Vue} ist ein progressives JavaScript-Framework, das durch seine Reaktivität und Modularität besticht. In der wissenschaftlichen Literatur wird \ac{Vue} häufig als ein Framework hervorgehoben, das sich durch seine Lernfreundlichkeit und die Fähigkeit zur schrittweisen Integration in bestehende Projekte auszeichnet (\cite{Li2021}). Laut \textcite{Novac2021} ist \ac{Vue} besonders geeignet für die Entwicklung von Single-Page Applications (SPAs), bei denen eine hohe Interaktivität der Benutzeroberfläche gefordert ist.
\clearpage
\ac{Nuxt} erweitert \ac{Vue} um Funktionen wie serverseitiges Rendering (SSR) und statische Seitengenerierung, die besonders für die Entwicklung von performanten und SEO-freundlichen Webanwendungen wichtig sind (\cite{Gomes2023}). SSR ist in der Lage, die Ladezeiten von Seiten zu reduzieren und die Benutzererfahrung zu verbessern, was besonders in datenintensiven Anwendungen von Bedeutung ist (\cite{Sianandar2022}).

\subsection{Tailwind CSS}
\ac{Tailwind} ist ein Utility-first CSS-Framework, das in der Webentwicklung zunehmend an Bedeutung gewinnt. Laut \textcite{Rifandi2022} erlaubt es \ac{Tailwind}, schnell prototypische Benutzeroberflächen zu erstellen, indem es eine grosse Anzahl von vorgefertigten CSS-Klassen bereitstellt. Diese Klassen sind darauf ausgelegt, ohne zusätzliche Anpassungen direkt im HTML-Code verwendet zu werden, was den Entwicklungsprozess beschleunigt und eine konsistente Gestaltung der Benutzeroberfläche gewährleistet (\cite{Rifandi2022}).\\[1em] In wissenschaftlichen Untersuchungen wird hervorgehoben, dass Utility-first-Ansätze wie \ac{Tailwind} eine höhere Flexibilität und Wiederverwendbarkeit von Code bieten, da sie Entwicklern ermöglichen, ohne Abhängigkeit von spezifischen Designsystemen oder vorgefertigten Komponenten zu arbeiten (\cite{Wang2023}).

\subsection{Python Flask}
Flask ist ein mikroframework für Python, das sich durch seine Einfachheit und Flexibilität auszeichnet. Es wurde erstmals von \textcite{Relan2019} beschrieben und hat sich seitdem als beliebte Wahl für die Entwicklung von Webanwendungen etabliert, insbesondere in Projekten, die eine schnelle und unkomplizierte Implementierung erfordern. Flask bietet grundlegende Funktionalitäten wie Routing und Vorlagen-Rendering, die durch eine Vielzahl von Erweiterungen an die spezifischen Bedürfnisse eines Projekts angepasst werden können (\cite{Chauhan2019}).\\[1em]Flask wird in vielen wissenschaftlichen Arbeiten als Beispiel für ein Framework hervorgehoben, das eine Balance zwischen Leichtigkeit und Erweiterbarkeit bietet, was es ideal für kleine bis mittelgrosse Webprojekte macht (\cite{PAZDRIY2023}). In deinem Projekt dient Flask als \ac{BE}-Framework, das die Kommunikation zwischen dem \ac{FE} und den Datenquellen ermöglicht, eine entscheidende Rolle bei der Integration von Datenverarbeitungsroutinen spielt und eine stabile Grundlage für die Anwendungslogik bietet.
\clearpage
\subsection{Datenvisualisierung und Benutzerfreundlichkeit}
Datenvisualisierung ist ein wesentlicher Bestandteil der Datenanalyse, der es ermöglicht, komplexe Datensätze in eine visuelle Form zu überführen, die leicht verständlich und interpretierbar ist. \textcite{Nair2018} betont, dass die Qualität der Visualisierung einen direkten Einfluss auf die Fähigkeit der Benutzer hat, aus den dargestellten Daten sinnvolle Erkenntnisse zu gewinnen.\\[1em]Benutzerfreundlichkeit ist ein weiterer kritischer Faktor bei der Entwicklung von Dashboards. Laut \textcite{Desai2016} bestimmt die Benutzerfreundlichkeit, wie effektiv, effizient und zufriedenstellend eine Softwarelösung ist. In der Dashboard-Entwicklung bedeutet dies, dass die Visualisierungen intuitiv bedienbar sein müssen und die Interaktionen so gestaltet sein sollten, dass sie die analytische Arbeit des Benutzers unterstützen und nicht behindern.\\[1em]Die Optimierung der Benutzeroberfläche und die Auswahl geeigneter Visualisierungstypen sind daher zentrale Herausforderungen, die durch eine Kombination von wissenschaftlichen Methoden und modernen technologischen Werkzeugen angegangen werden müssen (\cite{Saket2019}).
\clearpage
	\section{Stand der Forschung}
	\label{sec:standDerForschung}

\subsection{Entwicklung von Dashboards in der Datenvisualisierung}
Die Rolle von Dashboards in der Datenvisualisierung hat sich in den letzten Jahren erheblich weiterentwickelt. Ursprünglich wurden Dashboards vor allem als statische Berichtsplattformen genutzt, doch mit dem Aufkommen neuer Webtechnologien haben sich die Anforderungen an Dashboards stark verändert. Laut \textcite{Nunes2020} dienen moderne Dashboards nicht nur der Visualisierung von Daten, sondern auch der Interaktion mit diesen. Dadurch ermöglichen sie eine tiefere Analyse und ein besseres Verständnis der zugrunde liegenden Daten.\\[1em] Aktuelle Studien zeigen, dass die Effektivität von Dashboards stark von ihrer Fähigkeit abhängt, grosse und komplexe Datensätze in Echtzeit darzustellen und dem Benutzer intuitive Werkzeuge zur Verfügung zu stellen, um diese Daten zu manipulieren (\cite{Stehle2019}). Die Entwicklung solcher Dashboards erfordert daher nicht nur ein tiefes Verständnis der Benutzeranforderungen, sondern auch die Fähigkeit, leistungsstarke Visualisierungs- und Interaktionsmechanismen zu implementieren(\cite{Setlur2023}).

\subsection{Einsatz moderner Frontend-Technologien}
Moderne \ac{FE}-Technologien wie \ac{Vue} und \ac{Nuxt} spielen eine entscheidende Rolle bei der Entwicklung interaktiver Dashboards. Diese Technologien ermöglichen es Entwicklern, modulare und reaktive Benutzeroberflächen zu erstellen, die sich dynamisch an veränderte Daten und Benutzerinteraktionen anpassen. Laut \textcite{Dabbas2021} hat \ac{Vue} in den letzten Jahren erheblich an Popularität gewonnen, vor allem aufgrund seiner einfachen Integration und der Möglichkeit, komplexe Anwendungen mit minimalem Aufwand zu entwickeln.\\[1em] Ein weiterer wichtiger Aspekt ist die serverseitige Rendering-Funktionalität von \ac{Nuxt}, die besonders für Anwendungen mit hohem Datenaufkommen und der Notwendigkeit einer schnellen Ladezeit von Bedeutung ist (\cite{Bach2022}). Durch das serverseitige Rendering wird der initiale Ladevorgang der Seite beschleunigt, was die Benutzererfahrung erheblich verbessert.
\newpage

\subsection{Modularität und Dynamik in Dashboards}
Die Modularität von Dashboards ist ein Thema, das in der wissenschaftlichen Literatur ausführlich diskutiert wird. Ein modulares Dashboard-Design ermöglicht es, einzelne Komponenten unabhängig voneinander zu entwickeln, zu testen und zu aktualisieren, was die Wartbarkeit und Skalierbarkeit der Anwendung erheblich verbessert (\cite{Ullrich2019}). Dies ist besonders wichtig in Umgebungen, in denen Dashboards ständig aktualisiert werden müssen, um neuen Anforderungen gerecht zu werden.\\[1em]Die Dynamik von Dashboards bezieht sich auf ihre Fähigkeit, auf Benutzerinteraktionen in Echtzeit zu reagieren. Laut \textcite{Toasa2018} ist die Fähigkeit zur dynamischen Anpassung von Datenansichten ein Schlüsselfaktor für die Benutzerfreundlichkeit von Dashboards. Dies erfordert nicht nur fortschrittliche \ac{FE}-Technologien, sondern auch eine effiziente \ac{BE}-Architektur, die schnelle Datenabrufe und -verarbeitungen ermöglicht.

\subsection{Datenvisualisierung und Benutzerfreundlichkeit}
Die Benutzerfreundlichkeit von Dashboards ist ein weiteres zentrales Forschungsgebiet. Studien haben gezeigt, dass die Benutzerfreundlichkeit von Dashboards stark von der Qualität und Klarheit der Visualisierungen abhängt (\cite{HYNEK2015}). Die Auswahl der richtigen Visualisierungstypen und deren effektive Darstellung sind entscheidend, um den Benutzern zu helfen, komplexe Daten zu verstehen und fundierte Entscheidungen zu treffen.\\[1em]Ein weiteres wichtiges Kriterium ist die Interaktivität der Visualisierungen. Benutzer sollten in der Lage sein, durch einfache Aktionen wie Klicken, Zoomen oder Filtern tiefere Einblicke in die Daten zu gewinnen (\cite{Alhamadi2020}). Dies stellt hohe Anforderungen an das Design und die Implementierung der Benutzeroberfläche, insbesondere wenn es darum geht, eine Balance zwischen Funktionalität und Einfachheit zu finden.

\subsection{Aktuelle Herausforderungen und zukünftige Entwicklungen}
Trotz der Fortschritte in der Dashboard-Entwicklung stehen Entwickler nach wie vor einer Reihe von Herausforderungen. Eine der grössten Herausforderungen ist die Integration von grossen, heterogenen Datenquellen in ein einziges, kohärentes Dashboard. Die Skalierbarkeit und Performance solcher Systeme sind oft begrenzt, insbesondere wenn Dashboards in Echtzeit aktualisiert werden müssen (\cite{MartinezOrtiz2019}).\\[1em]Zukünftige Entwicklungen in diesem Bereich könnten durch den verstärkten Einsatz von Künstlicher Intelligenz und maschinellem Lernen vorangetrieben werden, die dazu beitragen könnten, die Datenanalyse zu automatisieren und die Benutzer bei der Interpretation der Ergebnisse zu unterstützen (\cite{Mukhopadhyay2019}). Ein weiteres Forschungsfeld ist die Verbesserung der Benutzerfreundlichkeit durch den Einsatz von natürlichen Sprachverarbeitungstechnologien, die es Benutzern ermöglichen, Dashboards durch sprachliche Anfragen zu steuern.(\cite{Kumar2021})
\clearpage
	\section{Methodik}
	\label{sec:standDerForschung}

{\subsection{Projektübersicht}}

Das Projekt \textit{DashyBuilder} wurde als Prototyp entwickelt, um die Forschungsfrage zu untersuchen, wie moderne \ac{FE}-Technologien zur Entwicklung eines dynamischen und modularen Dashboard-Layouts eingesetzt werden können, um die Benutzerfreundlichkeit und Wartbarkeit zu maximieren. Dieser Prototyp konzentriert sich darauf, grundlegende, aber essenzielle Funktionen zu demonstrieren, die in einem Dashboard notwendig sind, wobei ein klarer Fokus auf Modularität, Flexibilität und Erweiterbarkeit gelegt wurde.

\subsection{Entscheidung für das CSV-Dateiformat}
Die Entscheidung, ausschliesslich das \ac{CSV}-Dateiformat für den Datenimport zu verwenden, basiert auf der weit verbreiteten Nutzung und Standardisierung dieses Formats(\cite{Connelly2014}). \ac{CSV}-Dateien sind eines der am häufigsten verwendeten Formate für den Datenaustausch, insbesondere in den Bereichen Datenanalyse und Datenverarbeitung. Sie bieten eine plattformunabhängige Möglichkeit, Daten in einer textbasierten, leicht zugänglichen Form zu speichern, die von nahezu allen Datenverarbeitungstools unterstützt wird. Laut \textcite{Burg2019} gehört das \ac{CSV}-Format zu den am häufigsten verwendeten Formaten in der Datenwissenschaft, da es einfach zu handhaben und weitgehend kompatibel ist. Diese Eigenschaften machen \ac{CSV}-Dateien ideal für den Einsatz in einem Prototyp wie DashyBuilder, der darauf abzielt, grundlegende Funktionalitäten schnell und effektiv zu demonstrieren. Die einfache Struktur von \ac{CSV}-Dateien erleichtert zudem die Implementierung und Validierung von Datenverarbeitungsroutinen, was für die schnelle Entwicklung eines Prototyps entscheidend ist (\cite{Tapsai2018}). Darüber hinaus bleibt die Möglichkeit bestehen, das System später zu erweitern, um weitere Dateiformate zu unterstützen, falls die Anforderungen dies erfordern.

\subsection{Auswahl der Widget-Typen}
Im Rahmen von DashyBuilder wurde entschieden, sich auf vier zentrale Widget-Typen zu konzentrieren: Chart, Table, Filter Box und Text Block. Diese Auswahl basiert auf einer umfassenden Analyse der häufigsten Elemente in Dashboards und den grundlegenden Anforderungen an eine effektive Datenvisualisierung. Diagramme (Charts) sind unverzichtbar für die Darstellung von Trends und Mustern in Daten, da sie es ermöglichen, schnell fundierte Entscheidungen zu treffen (\cite{Wang2008}). Tabellen (Tables) dienen der übersichtlichen Darstellung grosser Datenmengen und sind somit besonders wichtig für detaillierte Analysen (\cite{Smailovic2012}). Filterboxen (Filter Boxes) bieten interaktive Möglichkeiten, spezifische Daten auszuwählen und fokussierte Analysen durchzuführen (\cite{Al-Zokari2020AN}), während Textblöcke (Text Blocks) wichtige Informationen und Erklärungen direkt im Dashboard präsentieren, um die Verständlichkeit und Benutzerführung zu unterstützen (\cite{Latif2022}). Die Konzentration auf diese vier Typen ermöglichte es, einen funktionalen Prototyp zu entwickeln, der die wesentlichen Anforderungen eines modernen Dashboards erfüllt. Da DashyBuilder als Prototyp konzipiert wurde, lag der Fokus auf der Reduktion der Komplexität, um den Entwicklungsprozess zu beschleunigen und die Forschungsfrage effizient zu beantworten. Gleichzeitig bleibt das System offen für zukünftige Erweiterungen, um weitere Widgets zu integrieren, sobald zusätzliche Anforderungen identifiziert werden.

\subsection{Implementierung des Frontends}
Das \ac{FE} von DashyBuilder wurde mit \ac{Nuxt} entwickelt, einem Framework, das auf \ac{Vue} basiert und zusätzliche Funktionen wie serverseitiges Rendering und statische Seitengenerierung bietet. \ac{Nuxt} wurde gewählt, weil es eine modulare Architektur bietet, die es ermöglicht, wiederverwendbare Komponenten zu erstellen und das \ac{FE} effizient zu skalieren (\cite{Alasaad2022}). Die Seitenstruktur umfasst verschiedene Hauptkomponenten, die die Kernfunktionen des Dashboards abdecken. Besonders hervorzuheben ist die Verwendung eines Grid-Layouts zur Anordnung der Widgets, das eine flexible und anpassbare Benutzeroberfläche ermöglicht (\cite{Freeman2019}). Durch die Implementierung dynamischer Routen und modularer Komponenten kann das Dashboard flexibel auf die unterschiedlichen Anforderungen der Benutzer reagieren, was die Benutzerfreundlichkeit und Wartbarkeit des Systems erheblich steigert.

\subsection{Implementierung des Backends}
Die Implementierung des Backends in DashyBuilder basiert auf Flask, einem leichtgewichtigen Web-Framework für Python, das sich durch seine Flexibilität und einfache Handhabung auszeichnet (\cite[S.119]{Relan2019}). Die zentrale Konfiguration der Anwendung, die in der Datei config.py definiert ist, stellt sicher, dass alle notwendigen Verzeichnisse, wie das Upload-Verzeichnis für \ac{CSV}-Dateien, vorhanden sind und korrekt konfiguriert werden(\cite{Chauhan2019}). Diese Konfiguration erleichtert die Verwaltung und Erweiterung der Anwendung, indem sie eine einheitliche und gut strukturierte Grundlage für die gesamte \ac{BE}-Logik bietet. Ein wesentlicher Bestandteil von DashyBuilder ist die dynamische Generierung von Dashboards, die es den Benutzern ermöglicht, ihre eigenen Dashboards zu erstellen, indem sie Widgets hinzufügen, anpassen und deren Position im Grid-Layout bestimmen(\cite{Vogel2017}). Diese Funktion wird durch den Code in dashboard.py realisiert, der das Layout und die Funktionsweise der Widgets in der Dash-Anwendung definiert. Die dynamische Generierung stellt sicher, dass das Dashboard flexibel und anpassbar bleibt, was besonders in Anwendungsbereichen mit wechselnden Anforderungen und sich schnell ändernden Daten von grossem Nutzen ist.

\subsection{Datenverarbeitung und Upload-Management}
Die Verwaltung von Datenuploads erfolgt in DashyBuilder über das Modul uploader.py, das speziell dafür entwickelt wurde, grosse Datensätze effizient zu verarbeiten. Der Upload-Mechanismus unterstützt das Hochladen in kleinen Chunks, was die Verarbeitung grosser Dateien ermöglicht, ohne dass es zu Speicherproblemen kommt (\cite{Mallafi2016}). Nach dem Upload werden die Daten nahtlos in das Dashboard integriert, wo sie analysiert und visualisiert werden können. Diese Architektur gewährleistet eine hohe Leistungsfähigkeit und Stabilität des Systems, selbst bei der Verarbeitung umfangreicher Datenmengen (\cite{PGohil2015}). Durch die Implementierung eines effizienten Upload- und Datenverarbeitungssystems wird sichergestellt, dass das Dashboard auch bei umfangreichen Datenanforderungen reaktionsschnell und zuverlässig bleibt.

\subsection{Zusammenfassung}
Die Entwicklung von DashyBuilder legt den Grundstein für ein modulares und flexibles Dashboard-System, das bereits in seiner prototypischen Form die wichtigsten Anforderungen an ein modernes Dashboard erfüllt. Die getroffenen Entscheidungen hinsichtlich der Auswahl der Datenformate und Widget-Typen sind wissenschaftlich fundiert und ermöglichen es, den Prototypen bei Bedarf problemlos zu erweitern und anzupassen. Mit DashyBuilder wurde eine Grundlage geschaffen, die sowohl für den unmittelbaren Einsatz als auch für die zukünftige Weiterentwicklung geeignet ist, um den Anforderungen moderner Datenvisualisierungs- und Analysewerkzeuge gerecht zu werden.
\clearpage
	\section{Ergebnisse}
	\label{sec:ergebnisse}

In diesem Kapitel werden die Ergebnisse der Entwicklung und Implementierung des Prototyps DashyBuilder wissenschaftlich dargestellt und analysiert. Der Fokus liegt dabei auf der dynamischen Generierung von Dashboards, der effizienten Verarbeitung und Integration von Daten, der Flexibilität und Erweiterbarkeit des Systems sowie der Berechnung der Widget-Positionen im Grid-Layout. Diese Ergebnisse sind entscheidend, um die Forschungsfrage zu beantworten, wie moderne \ac{FE}-Technologien zur Entwicklung eines dynamischen und modularen Dashboard-Layouts eingesetzt werden können.
\subsection{Dynamische Generierung von Dashboards}
Ein zentraler Aspekt des DashyBuilder-Prototyps ist die Fähigkeit zur dynamischen Generierung von Dashboards. Diese Funktion ermöglicht es, basierend auf den Eingaben der Benutzer verschiedene Widgets in einem Grid-Layout anzuordnen und diese in eine funktionsfähige Anwendung zu integrieren.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/dashboard_example.png}
    \caption{Ein Beispiel-Dashboard, das mit DashyBuilder erstellt wurde, zeigt die dynamische Anordnung von Widgets.}
    \label{fig:dashboard_example}
\end{figure}
Die dynamische Generierung wird durch den Code im Modul \textit{dashboard.py} realisiert, der die Anordnung und das Layout der Widgets bestimmt.\\[1em]Der Prozess der dynamischen Generierung stützt sich auf die flexible Struktur von JavaScript-Frameworks wie \ac{Vue}, die durch ihre Komponentenarchitektur eine einfache Wiederverwendung und Anpassung von UI-Elementen ermöglichen (\cite{Alasaad2022}). Die Verwendung von Plotly für die Datenvisualisierung gewährleistet dabei eine hochwertige und interaktive Darstellung der Daten, die in Dashboards unerlässlich ist (\cite{Clement2020}).\\[1em] 
Der folgende Code zeigt, wie das Layout der Widgets dynamisch generiert wird:

\begin{algorithm}[H]
\SetAlgoLined
\KwData{widgets, grid\_size}
\KwResult{plotly\_code}
$cols, rows \gets$ split grid\_size by 'x' and convert to integers\;
$widget\_classes \gets \{$"Chart": ChartWidget, "Table": TableWidget, "Text Block": TextBlockWidget, "Filter Box": FilterBoxWidget$\}$\;
$function\_definitions \gets$ empty list\;
$layout\_components \gets$ empty list\;

\For{each widget in widgets}{
    $widget\_type \gets$ widget's type\;
    $widget\_class \gets widget\_classes[widget\_type]$\;
    $widget\_instance \gets$ instantiate $widget\_class$ with $widget, cols$\;
    $function\_definitions$.append($widget\_instance.generate\_code()$)\;
    $layout\_component \gets$ generate layout for $widget\_instance$\;
    $layout\_components$.append($layout\_component$)\;
}

$plotly\_code \gets$ concatenate $function\_definitions$ and $layout\_components$\;
\caption{Pseudocode für die Funktion \texttt{generate\_plotly\_code}}
\end{algorithm}

Durch diesen Ansatz wird sichergestellt, dass die Widgets korrekt im Grid-Layout positioniert und gerendert werden. Diese dynamische Generierung bietet eine hohe Flexibilität und ermöglicht es den Benutzern, Dashboards individuell nach ihren Bedürfnissen zu gestalten.
\subsection{Datenverarbeitung und Integration}
Ein weiteres zentrales Ergebnis ist die effiziente Verarbeitung und Integration von \ac{CSV}-Daten. Der Upload-Mechanismus, implementiert in \textit{uploader.py}, ermöglicht das Hochladen grosser Datensätze in kleinen Chunks, was Speicherprobleme vermeidet und die Robustheit des Systems erhöht(\cite{Ge2019}).
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/upload_process.png}
    \caption{Der Upload-Prozess großer CSV-Dateien in DashyBuilder, aufgeteilt in kleinere Chunks.}
    \label{fig:upload_process}
\end{figure}
Diese Methode basiert auf Techniken, die in der Literatur als effektiv für den Umgang mit grossen Datensätzen beschrieben werden.\\[1em] Die Entscheidung, das \ac{CSV}-Format für den Datenaustausch zu verwenden, wurde aufgrund seiner weitverbreiteten Nutzung und der einfachen Handhabung getroffen. Laut \textcite{Freeman2019} ist \ac{CSV} eines der am häufigsten verwendeten Formate für den Datenaustausch in der Wissenschaft und der Industrie, da es plattformübergreifend kompatibel ist und leicht von verschiedenen Analysetools verarbeitet werden kann. Der folgende Code zeigt den Upload-Mechanismus, der es ermöglicht, grosse Dateien in kleinere Teile zu zerlegen und effizient hochzuladen:
\newpage
\begin{algorithm}[H]
\SetAlgoLined
\KwIn{HTTP request containing a file chunk}
\KwOut{JSON response indicating success or error}
\If{\texttt{'chunk'} not in \texttt{request.files}}{
    \textbf{return} JSON object with \{`error': `No chunk part'\}, HTTP status code 400\;
}
$chunk \gets$ \texttt{request.files['chunk']}\;
$chunk\_number \gets$ \texttt{request.form['chunkNumber']}\;
$total\_chunks \gets$ \texttt{request.form['totalChunks']}\;
$filename \gets$ \texttt{request.form['filename']}\;
$dataset\_id \gets$ \texttt{filename.replace('.', '\_')}\;
$chunk\_folder \gets$ \texttt{os.path.join(self.upload\_folder, dataset\_id)}\;
\If{\texttt{not os.path.exists(chunk\_folder)}}{
    \texttt{os.makedirs(chunk\_folder)}\;
}
\texttt{chunk.save(os.path.join(chunk\_folder, f"\{chunk\_number\}.part"))}\;
\textbf{return} JSON object with \{`message': `Chunk uploaded successfully'\}\;
\caption{Pseudocode für die Methode \texttt{upload\_chunk}}
\end{algorithm}
Diese Implementierung ermöglicht eine nahtlose Integration der Daten in das Dashboard, wo sie sofort zur Analyse und Visualisierung zur Verfügung stehen. Diese Architektur gewährleistet eine hohe Leistungsfähigkeit und Stabilität des Systems, selbst bei der Verarbeitung grosser Datenmengen

\subsection{Flexibilität und Erweiterbarkeit des Dashboards}
Die Flexibilität und Erweiterbarkeit von DashyBuilder wurden ebenfalls gründlich untersucht. Der Prototyp erlaubt es, verschiedene Widget-Typen dynamisch hinzuzufügen und zu konfigurieren. Diese Modularität wird durch die Verwendung von Klassen für die Widgets unterstützt, was eine einfache Erweiterbarkeit und Anpassbarkeit des Systems gewährleistet. Beispielsweise zeigt der folgende Code die Implementierung des Chart-Widget-Moduls, das es ermöglicht, neue Diagramme in das Dashboard zu integrieren:
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/chart_widget_config.png}
    \caption{Hinzufügen und Konfigurieren eines Chart-Widgets in DashyBuilder.}
    \label{fig:chart_widget_config}
\end{figure}
\begin{algorithm}[H]
\small % oder \footnotesize, je nachdem wie klein du es haben möchtest
\SetAlgoLined
\SetKwFunction{GenerateCode}{generate\_code}

\KwData{self.name}
\KwResult{Python code for drawing a chart}

\textbf{Class} \texttt{ChartWidget} inherits from \texttt{Widget}\;
\textbf{Method} \GenerateCode{}\;

self.title $\gets$ self.name\;
self.name $\gets$ self.name.replace(" ", "")\;

\Return \texttt{f"""}

\begin{lstlisting}[language=Python]
def drawChart_<self.name>():
    fig = px.pie(df, names='species', values='sepal_length').update_layout(
        title={'text': self.title, 'y': 0.95, 'x': 0.01, 'xanchor': 'left', 'yanchor': 'top'},
        template='plotly_dark',
        plot_bgcolor='rgba(0, 0, 0, 0)',
        paper_bgcolor='rgba(0, 0, 0, 0)',
        margin=dict(l=20, r=20, t=40, b=20)
    )
    return html.Div([
        dbc.Card(
            dbc.CardBody([
                dcc.Graph(
                    id='<self.name>_graph',
                    figure=fig,
                    config={'displayModeBar': False},
                    style={'height': '100%', 'width': '100%'},
                    responsive=True
                )
            ]), style={'height': '100%'}
        )
    ], style={'height': '100%', 'padding': '2px'})
\end{lstlisting}

\caption{Pseudocode für die Methode \texttt{generate\_code} in der Klasse \texttt{ChartWidget}}
\end{algorithm}
Diese Modularität erlaubt es, das Dashboard flexibel an die Bedürfnisse der Benutzer anzupassen und bei Bedarf neue Widgets hinzuzufügen. Dies ist besonders wichtig in Umgebungen, in denen sich die Anforderungen an das Dashboard schnell ändern können.
\newpage
\subsection{Berechnung der Widget-Positionen im Grid-Layout}
Ein weiterer wichtiger Aspekt ist die Methode zur Berechnung der Positionen und Grössen der Widgets im Grid-Layout, die in der Klasse Widget implementiert ist. Diese Methode \textit{parse\_grid\_positions} ist dafür verantwortlich, die vom Benutzer angegebenen Positionen zu analysieren und die entsprechende Ausdehnung der Widgets im Grid zu berechnen.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/grid_layout_visualization.png}
    \caption{Visualisierung der Widget-Positionen im Grid-Layout in DashyBuilder.}
    \label{fig:grid_layout_visualization}
\end{figure}
\begin{algorithm}[H]
\SetAlgoLined

\textbf{Class:} Widget \;
\textbf{Function:} parse\_grid\_positions(grid\_position\_str, cols) \;
\KwIn{grid\_position\_str: String of grid positions, cols: Number of columns}
\KwOut{min\_row, min\_col, row\_span, col\_span}

\textbf{Step 1:} Convert grid\_position\_str into a list of integers \;
$positions \gets$ \textbf{list}(map(int, grid\_position\_str.split(',')))\;

\textbf{Step 2:} Calculate row and column positions \;
$row\_positions \gets [(pos - 1) // cols + 1 \textbf{for each} pos \textbf{in} positions]$\;
$col\_positions \gets [(pos - 1) \% cols + 1 \textbf{for each} pos \textbf{in} positions]$\;

\textbf{Step 3:} Determine minimum and maximum rows and columns \;
$min\_row \gets \min(row\_positions)$\;
$max\_row \gets \max(row\_positions)$\;
$min\_col \gets \min(col\_positions)$\;
$max\_col \gets \max(col\_positions)$\;

\textbf{Step 4:} Calculate row span and column span \;
$row\_span \gets max\_row - min\_row + 1$\;
$col\_span \gets max\_col - min\_col + 1$\;

\Return{$min\_row, min\_col, row\_span, col\_span$}

\caption{Pseudocode für die Methode \texttt{parse\_grid\_positions} in der Klasse \texttt{Widget}}
\end{algorithm}

Diese Methode ermöglicht es, die Widgets präzise im Grid zu platzieren, was besonders wichtig für die Benutzererfahrung ist. Die korrekte Platzierung und Größenbestimmung der Widgets trägt massgeblich zur Ästhetik und Funktionalität des Dashboards bei und verhindert Überlappungen oder Lücken in der Darstellung.

\subsection{Performance und Benutzerfreundlichkeit}
Die Performance des DashyBuilder-Prototyps wurde unter verschiedenen Bedingungen getestet, insbesondere hinsichtlich der Verarbeitung grosser Datensätze und der Reaktionszeit des Dashboards bei dynamischen Änderungen. Die Ergebnisse zeigen, dass das System auch bei umfangreichen Datenmengen eine hohe Performance aufrechterhält und Änderungen in Echtzeit verarbeitet werden können. Diese Ergebnisse bestätigen die Eignung der verwendeten Technologien und die Wirksamkeit des Implementierungsansatzes.\\[1em]Die Benutzerfreundlichkeit des Dashboards wurde durch die Nutzung von \ac{Nuxt} und \ac{Tailwind} optimiert, die zur Schaffung einer konsistenten und ansprechenden Benutzeroberfläche beitragen. Diese Technologien unterstützen die Entwicklung intuitiver und benutzerfreundlicher Interfaces, was besonders in Dashboards von grosser Bedeutung ist (\cite{Pastushenko2019}).

\subsection{Zusammenfassung der Ergebnisse}
Zusammenfassend lässt sich sagen, dass DashyBuilder als Prototyp die gestellten Anforderungen erfüllt und eine solide Grundlage für die Entwicklung eines dynamischen und modularen Dashboards bildet. Die dynamische Generierung von Dashboards, die effiziente Datenverarbeitung und Integration, die Flexibilität und Erweiterbarkeit sowie die präzise Berechnung der Widget-Positionen im Grid-Layout sind zentrale Ergebnisse, die die Benutzerfreundlichkeit und Wartbarkeit des Systems unterstreichen. Die getroffenen Entscheidungen hinsichtlich der Auswahl der Technologien und Methoden sind wissenschaftlich fundiert und tragen massgeblich zur erfolgreichen Umsetzung des Prototyps bei.
\clearpage
	\section{Diskussion}
	\label{sec:diskussion}

\subsection{Interpretation der Ergebnisse}
Die im vorherigen Kapitel vorgestellten Ergebnisse zeigen, dass der entwickelte Prototyp DashyBuilder die in der Forschungsfrage gestellten Anforderungen in hohem Masse erfüllt. Die dynamische Generierung von Dashboards, die effiziente Datenverarbeitung und die Flexibilität des Systems sind zentrale Merkmale, die die Benutzerfreundlichkeit und Wartbarkeit von Dashboards deutlich verbessern.\\[1em]Die Entscheidung, sich auf das \ac{CSV}-Format als primäres Dateiformat zu konzentrieren, hat sich als pragmatisch und effektiv erwiesen. Wie bereits in der Literatur betont (\cite{Freeman2019}), gehört das \ac{CSV}-Format zu den am weitesten verbreiteten Formaten im Datenmanagement, insbesondere in der Datenanalyse. Die einfache Struktur von \ac{CSV}-Dateien erleichtert die Implementierung und Integration in Dashboards, was für den schnellen Prototyping-Prozess entscheidend war.

\subsection{Vergleich mit der bestehenden Literatur}
Die Ergebnisse von DashyBuilder stehen im Einklang mit den Erkenntnissen aus der bestehenden Literatur zu modernen \ac{FE}-Technologien und deren Anwendung in der Dashboard-Entwicklung. Die Wahl von \ac{Vue} und \ac{Nuxt} als \ac{FE}-Technologien hat sich als besonders geeignet erwiesen, da diese Frameworks durch ihre Komponentenstruktur eine hohe Wiederverwendbarkeit und Modularität bieten. Dies entspricht den Anforderungen an moderne Webanwendungen, die flexibel und erweiterbar sein müssen.\\[1em]Ein wesentlicher Aspekt, der in der Literatur oft betont wird, ist die Wichtigkeit der Benutzerfreundlichkeit in Dashboards (\cite{Desai2016}). Die Implementierung von interaktiven Widgets, die dem Benutzer ermöglichen, Daten auf vielfältige Weise zu visualisieren und zu analysieren, trägt wesentlich zu einer positiven Benutzererfahrung bei. In DashyBuilder wurde dies durch die Auswahl von vier spezifischen Widget-Typen (Charts, Tables, Filter Boxes, Text Blocks) erreicht, die grundlegende Anforderungen an die Datenvisualisierung abdecken.

\subsection{Limitationen des Prototyps}
Trotz der positiven Ergebnisse gibt es auch einige Limitationen des Prototyps, die es zu beachten gilt. Erstens ist DashyBuilder derzeit auf eine begrenzte Anzahl von Widget-Typen und das \ac{CSV}-Format beschränkt. Obwohl dies für die Beantwortung der Forschungsfrage ausreichend war, könnte die Unterstützung weiterer Formate und Widget-Typen in Zukunft notwendig sein, um das System für eine breitere Anwendung nutzbar zu machen.\\[1em]Zweitens ist die aktuelle Implementierung stark auf die vorgegebenen Layout-Strukturen und Grid-Grössen beschränkt. In komplexeren Anwendungsszenarien könnten flexiblere Layout-Optionen erforderlich sein, um den unterschiedlichen Anforderungen der Benutzer gerecht zu werden. Dies könnte durch die Implementierung einer dynamischeren Layout-Engine erreicht werden, die es Benutzern ermöglicht, noch freier mit der Anordnung und Grösse der Widgets zu experimentieren.

\subsection{Ausblick und zukünftige Arbeiten}
Auf Grundlage der erzielten Ergebnisse und der identifizierten Limitationen eröffnen sich mehrere potenzielle Richtungen für zukünftige Arbeiten. Eine Erweiterung von DashyBuilder könnte die Unterstützung weiterer Dateiformate wie JSON oder XML umfassen, um die Flexibilität bei der Datenintegration zu erhöhen. Darüber hinaus könnten zusätzliche Widget-Typen implementiert werden, um spezifische Anforderungen bestimmter Anwendungsfälle zu erfüllen, zum Beispiel spezialisierte Diagrammtypen oder interaktive Datenkarten.\\[1em]Ein weiterer interessanter Ansatz wäre die Integration von maschinellem Lernen in das Dashboard, um automatische Vorschläge für Datenvisualisierungen oder Anomalieerkennungen zu generieren. Dies könnte die Benutzerfreundlichkeit weiter steigern und die Möglichkeiten der Datenanalyse erheblich erweitern.\\[1em]Zudem könnte die Optimierung der Performance des Dashboards durch den Einsatz von serverseitigem Rendering und der Vorverarbeitung grosser Datenmengen in Betracht gezogen werden. Dies würde besonders in Szenarien mit Echtzeitdaten eine noch bessere Benutzererfahrung ermöglichen.

\subsection{Fazit}
Zusammenfassend lässt sich sagen, dass der entwickelte Prototyp DashyBuilder einen wertvollen Beitrag zur Untersuchung der Forschungsfrage geleistet hat. Die Ergebnisse zeigen, dass moderne \ac{FE}-Technologien wie \ac{Vue} und \ac{Nuxt} hervorragend geeignet sind, um dynamische und modulare Dashboards zu entwickeln, die sowohl benutzerfreundlich als auch wartbar sind. Die in dieser Arbeit entwickelten Konzepte und der Prototyp bieten eine solide Grundlage für weitere Entwicklungen in diesem Bereich.
\clearpage
	\section{Danksagung}
	\label{sec:danksagung}
An dieser Stelle möchte ich mich herzlich bei meiner Praktikumsbetreuerin Dr. rer. nat. Helena Jambor und meinem Betreuer Dr. rer. nat. Michael Burch für die hervorragende Zusammenarbeit und die Ermöglichung des Praktikums bedanken. Ihre fachliche Unterstützung und wertvollen Anregungen haben massgeblich zum Erfolg dieses Projekts beigetragen.\\[1em]Ebenfalls möchte ich meine Dankbarkeit gegenüber allen Mitarbeiterinnen und Mitarbeitern des DAViS-Instituts ausdrücken, deren Engagement und Hilfsbereitschaft während meiner Praktikumszeit von unschätzbarem Wert waren. Ihr wertvolles Feedback und ihre stetige Unterstützung haben es mir ermöglicht, meine Fähigkeiten weiterzuentwickeln und dieses Projekt erfolgreich abzuschliessen.


%\end{landscape}
\intextsep 5pt




%Literaturverzeichnis
%------------------------------------------------------------
%Verwendete Literatur
\newpage
\pagenumbering{Roman}
\setcounter{page}{4}
%\setlength{\bibitemsep}{2\itemsep} %Abstand zwischen den Einträgen im Literaturverzeichnis
 % Erstellen des Literaturverzeichnisses nur unter Berücksichtigung der Quelleneinträge mit de keyword "verwendet" das keyword ist manuell einzufügen.

%Weiterführende Literatur
\newpage
\nocite{*} % Setzt alle Einträge in der .bib Datei als "zitiert"
\printbibliography[heading=bibnumbered, title={Literaturverzeichnis}, notkeyword=verwendet] % schreibt alle Quellen ins Verzeichnis, die nicht über das keyword "verwendet" verfügen. 
%\printbibliography[heading=subbibnumbered, title={Weiterführende Literatur}, keyword=verwendet]





%------------------------------------------------------------


%Glossar
%------------------------------------------------------------
%\newpage
%------------------------------------------------------------

%pdf einfügen
%--------------------------------------------------------------
%\includepdf[pages={1}]{eigenstandigkeitserklarung.pdf}


%--------------------------------------------------------------


	%\end{flushleft}


\end{document}