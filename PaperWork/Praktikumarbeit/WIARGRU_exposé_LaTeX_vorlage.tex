%LaTeX-Vorlage --------------------------------------Rev. 1.1

%Verfasser:

%David Schober
%Meienriedweg 15
%2556 Scheuren
%Student BSc Informationswissenschaften der FHGR
%isc_tz_z_21
%david.schober@stud.fhgr.ch

%Diese Vorlage steht unter der CC0-Lizenz. Das betrifft den Quelltext sowie die formalen Aspekte wie Gestaltung und Formatierung.
%Die Angaben zum Autor sind nur vorhanden, falls eine Quellenangabe trotzdem vorgeschrieben wird.
%Das ist auch der einzige Grund sie in der Vorlage aufzuführen und zu belassen.
%Sieht am fertigen Dokument sowieso niemand! :-)

%Die Probleme zwischen den Lizenzen für die Nutzung der Vorlage bzw. für die Nutzung der Inhalte ergeben sich insofern nicht, da für die Nutzerinnen der Vorlage die Inhalte irrelevant sind. Zugleich haben die Nutzerinnen der Inhalte die Vorlage nicht.


\documentclass[a4paper, 12pt]{scrartcl}

%Ab hier die zu ladenden Pakete
%------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath, amssymb, amstext}
\usepackage{nameref}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{pgfgantt}
\usepackage{pdflscape} % Für das Drehen der Seite im PDF
\usepackage[a4paper,margin=1in]{geometry}

\definecolor{dukeblue}{rgb}{0.0, 0.0, 0.61}
%------------------------------------------------------------


%Ab hier für Schriftart und Schrift
%------------------------------------------------------------
\linespread{1.3} %Setze Zeilenabstand auf 1.3
\usepackage{mathptmx} %Lade Times ähnliche Schriftart
\usepackage{sectsty}
\allsectionsfont{\rmfamily\raggedright} %Setze Schriftart für alle Überschriften
\setkomafont{sectioning}{\normalcolor\bfseries}
\setkomafont{sectionentrypagenumber}{\normalcolor\mdseries}
%------------------------------------------------------------


%Ab hier für manuelle Seitengeometrie
%------------------------------------------------------------
\usepackage{geometry} %Lade Paket für manuelle Seitengeometrie
\geometry{a4paper, left=30mm, right=25mm, top=25mm, bottom=30mm}
\headsep = 22pt %Setze Abstände für die Seitenränder
%------------------------------------------------------------


%Ab hier für Kopf- und Fusszeile
%------------------------------------------------------------
\usepackage{fancyhdr} %Lade Paket für Kopf- und Fusszeile
\renewcommand{\headrulewidth}{0pt} % Keine Linie unter Kopfzeile
\renewcommand{\footrulewidth}{0.5pt} %Linie unter Fusszeile
\pagestyle{fancy} %Definiere Stil der Kopf- und Fusszeile
\lhead{\footnotesize{}} %Leer --> wird nicht angezeigt, bis manueller aufruf
\rhead{\footnotesize{}} %Leer --> wird nicht angezeigt, bis manueller aufruf
\cfoot{} %Leer --> wird nicht angezeigt, bis manueller aufruf
%------------------------------------------------------------


%Ab hier für Biblatex
%------------------------------------------------------------
\usepackage[style=apa, citetracker=true, maxcitenames=1, backend=biber]{biblatex}

\DeclareLanguageMapping{german}{german-apa}

\usepackage[babel, german=quotes]{csquotes} 

\AtEveryCitekey{%
	\ifciteseen{}{\defcounter{maxnames}{6}\clearfield{namehash}}}


\addbibresource{literatur.bib}
%-------------------------------------------------------------


%Ab hier sind neu definierte Kommandos
%-------------------------------------------------------------
%Dieses Komando übergibt das selbe "Sektionslabel"(gültig für \section{xxx}, \subsection{xxx} usw.) an drei verschiedene Referenzkommandos: 1. Gliederungsebene, 2. Überschrift, 3. Seitenzahl im Dokument.
\newcommand{\rtpref}[1]{Punkt~\ref{#1} \nameref{#1} ab 			Seite~\pageref{#1}}
%Verwendug: \rtpref{"Sektionslabel"nach Wahl} 
%Output: Punkt X.(X).(X) YYYYYYYYYYY ab Seite N(N) 
%z.B.----> Punkt 2.1.2 Profession ab Seite 2
\newcommand{\figref}[1]{Abbildung~\ref{#1} \nameref{#1} auf Seite~\pageref{#1}}

%Dieses Komando setzt den Text in den geschweiften Klammern fett und kursiv.
\newcommand{\texbfit}[1]{\textbf{\textit{#1}}}
%Verwendung: \texbfit{Fett und kursiv}
%Output: Fetter und kursiver Text.
%-------------------------------------------------------------


%Ab hier alles für Tabellen und Abbildungen
%-------------------------------------------------------------
\usepackage[justification=justified, singlelinecheck=false]{caption}
\usepackage{tabularx}
\usepackage{tabulary}
%-------------------------------------------------------------


%Ab hier für Links
%-------------------------------------------------------------
\usepackage[linktocpage=true, colorlinks=true, linkcolor=dukeblue, citecolor=dukeblue, filecolor=dukeblue, urlcolor=dukeblue]{hyperref}
%-------------------------------------------------------------


%Ab hier das Paket für Abkürzungen
%-------------------------------------------------------------
\usepackage[printonlyused, withpage]{acronym}

%Weitere Optionen, Befehle und Aufrufe siehe:
%https://www.namsu.de/Extra/pakete/Acronym.html
%-------------------------------------------------------------

\begin{document}

%Titelseite
%-------------------------------------------------------------
\begin{center}
	{\LARGE\textbf{Entwicklung eines dynamischen und modularen Dashboard-Layouts unter Verwendung moderner Frontend-Technologien}}\\
	\vspace{40mm} %Vertikaler Abstand 70mm
	{\large\textbf{Praktikumarbeit}}\\
	\vspace{40mm}

\begin{flushleft}
	\begin{tabbing}
		\hspace*{73mm}\= \kill
		Verfasser: \> Sangeeths Chandrakumar\\
		\> Riedenhaldenstrasse 26\\
		\> 8046 Zürich\\
		\> {sangeeths.chandrakumar@stud.fhgr.ch}\\
	\end{tabbing}
	
	\begin{tabbing}
		\hspace*{73mm}\= \kill
		Studiengang: \> BSc Computational and Data Science\\
		\hspace*{73mm}\= \kill
		Modul: \> Fachpraktikum (cds-902)\\
		\hspace*{73mm}\= \kill
		Praktikumsbetreuer: \> Dr. rer. nat Helena JAMBOR\\
	\end{tabbing}

    \begin{tabbing}
        \hspace*{73mm}\= \kill
        Praktikumsbetrieb: \> \parbox[t]{0.6\textwidth}{Institut für Data Analysis, Artificial Intelligence, \\ Visualization und Simulation (DAViS)}\\
        \hspace*{73mm}\= \kill
        Betreuer: \> Dr. rer. nat Michael Burch\\
    \end{tabbing}
 
	\begin{tabbing}
		\hspace*{73mm}\= \kill
		Bearbeitungszeitraum: \> 20. September 2024 bis  21. Januar 2024 \\
	\end{tabbing}
	
\end{flushleft}

\vspace{10mm}

\newcommand{\ausgeschriebenerMonat}[1]{%
    \ifcase#1\or Januar\or Februar\or März\or April\or Mai\or Juni\or Juli\or August\or September\or Oktober\or November\or Dezember\fi%
}

\newcommand{\datum}{%
    \textbf{Chur, \number\day.\ausgeschriebenerMonat{\month} \number\year}
}
\datum

\end{center}

\thispagestyle{empty} %Seite ohne Kopf- und Fusszeile
%-------------------------------------------------------------



%Abstract
%-------------------------------------------------------------
%\newpage
%\thispagestyle{empty}
%\thispagestyle{fancy}
%\lhead{\footnotesize{Text}}
%\rhead{\footnotesize{Text}}

%\begin{flushleft}
%\textbf{\Large\bigskip{Abstract}}


%\end{flushleft}
%-------------------------------------------------------------


%Inhalts- Abbildungs und Tabellenverzeichnis
%-------------------------------------------------------------
\newpage
\rfoot{\footnotesize \thepage} %Setze Sitenzahl in der Fusszeile rechts
\pagenumbering{Roman} %Verwende römische Zahlen
\setcounter{page}{1} %Beginne Seitennummerierung bei 1
\lfoot{\footnotesize Sangeeths Chandrakumar} %Setze Name in der Fusszeile links
\cfoot{\footnotesize Wissenschaftliches Arbeiten (cds-9031)}

\begin{flushleft}
\tableofcontents

\newpage
\cleardoublepage
\addcontentsline{toc}{section}{\listfigurename}
\listoffigures

%Tabelleverzeichnis
\newpage
\cleardoublepage
\addcontentsline{toc}{section}{\listtablename}
\listoftables 

%\newpage
%\cleardoublepage
%\addcontentsline{toc}{section}{Abkürzungsverzeichnis}
%\section*{Abkürzungsverzeichnis}
%\begin{acronym}[z.B.]
%	\acro{zb}[z.B.]{zum Beispiel}
%	\acro{kde}[KDE]{K Desktop Environment}
%\end{acronym}

%Es gibt die kurze und die lange Form von \ac{zb} ...
%\ac{kde}\\
%\ac{kde}
%Beim zweiten Mal \ac{zb}

\end{flushleft}
%-------------------------------------------------------------



% Ab hier beginnt die Arbeit
%-------------------------------------------------------------
\newpage
\pagenumbering{arabic} %Verwende arabische Zahlen
\setcounter{page}{1} %Beginne Seitennummerierung bei 1


	%\begin{flushleft}
		
	\section{Einleitung}
	\label{sec:einleitung}

\subsection{Einführung in das Thema}
Die Entwicklung dynamischer und modularer Dashboard-Layouts ist ein zentraler Aspekt moderner Webanwendungen, insbesondere im Bereich Data Science und Computational Science. Dashboards fungieren als wesentliche Schnittstelle zur Visualisierung und Analyse von Daten, was sie zu einem wichtigen Instrument für die Entscheidungsfindung in Unternehmen macht (\cite[S.119]{Bach2022}). Ein effektives Dashboard-Design erfordert nicht nur eine ansprechende Benutzeroberfläche, sondern auch eine hohe Flexibilität und Modularität, um den vielfältigen Anforderungen der Benutzer gerecht zu werden.\\[1em] Aktuelle Studien zeigen, dass die Wahl der richtigen Frontend-Technologien entscheidend für den Erfolg solcher Dashboards ist. So betonen (\cite[S.119]{Raposo2022}), dass moderne JavaScript-Frameworks wie Vue.js und React aufgrund ihrer Komponentenstruktur und Wiederverwendbarkeit besonders geeignet sind, um komplexe und dynamische Benutzeroberflächen zu gestalten. Diese Arbeit untersucht die Entwicklung eines dynamischen und modularen Dashboard-Layouts unter Verwendung moderner Frontend-Technologien, insbesondere Vue 3, Nuxt 3 und Tailwind CSS, in Verbindung mit einem Python Flask Backend.

\subsection{Problemstellung}
Die Entwicklung von Dashboards steht vor mehreren Herausforderungen, die sowohl technischer als auch benutzerorientierter Natur sind. Zum einen müssen Dashboards flexibel genug sein, um sich an verschiedene Datenquellen und Anwendungsszenarien anzupassen (\cite[S.119]{Matheus2020}). Zum anderen sollten sie modular aufgebaut sein, um die Wartbarkeit und Erweiterbarkeit zu gewährleisten, was in grossen und langfristigen Projekten entscheidend ist (\cite[S.119]{Behrisch2018}). Traditionelle Frontend-Frameworks bieten zwar viele Funktionen, stossen jedoch oft an ihre Grenzen, wenn es darum geht, komplexe Anforderungen an Dynamik und Modularität zu erfüllen.\\[1em] Ein weiterer wichtiger Aspekt ist die Performance, insbesondere wenn Dashboards grosse Datenmengen in Echtzeit visualisieren müssen. Studien haben gezeigt, dass die Wahl der Architektur und der verwendeten Technologien massgeblich die Performance beeinflusst, was wiederum die Benutzererfahrung und die Effizienz der Datenanalyse direkt betrifft (\cite[S.119]{Shneiderman2006}).

\subsection{Zielsetzung der Arbeit}
Das Hauptziel dieser Arbeit ist es, die Potenziale und Grenzen moderner Frontend-Technologien bei der Entwicklung dynamischer und modularer Dashboard-Layouts zu untersuchen. Im Rahmen dieses Projekts wird ein flexibles Layout-Management-System entwickelt, das die Anordnung und Skalierung verschiedener Inhaltsboxen (Widgets) ermöglicht. Besonders Augenmerk wird dabei auf die Benutzerfreundlichkeit und Wartbarkeit des Dashboards gelegt. Daraus ergibt sich die zentrale Forschungsfrage dieser Arbeit:\\[1em]
\textit{„Wie können moderne Frontend-Technologien zur Entwicklung eines dynamischen und modularen Dashboard-Layouts eingesetzt werden, um die Benutzerfreundlichkeit und Wartbarkeit zu maximieren?“}\\[1em] Dieses Vorhaben adressiert eine wesentliche Lücke in der aktuellen Lage der Datenvisualisierung: die Balance zwischen technischer Komplexität und Nutzerfreundlichkeit. Während moderne Technologien wie Vue 3, Nuxt 3 und Tailwind CSS leistungsstarke Werkzeuge zur Entwicklung dynamischer und modularer Dashboards bieten, bleibt die Herausforderung bestehen, diese Technologien so zu nutzen, dass sie auch für Benutzer ohne tiefgehende Programmierkenntnisse zugänglich sind. Diese Arbeit verspricht, einen Weg zu ebnen, auf dem in naher Zukunft jeder, der Einblicke in seine Daten gewinnen möchte, dies unabhängig von seinen technischen Fähigkeiten erreichen kann. Dies würde nicht nur die Effizienz und Flexibilität von Dashboards steigern, sondern auch deren Einsatzmöglichkeiten erheblich erweitern.
\newpage
	\section{Grundlagen}
	\label{sec:grundlagen}
 
\subsection{Plotly Dash}
Plotly Dash ist ein Framework zur Entwicklung interaktiver Webanwendungen, das speziell für den Einsatz in der Datenvisualisierung konzipiert wurde. Dash ermöglicht es, komplexe Datenanalysen und -visualisierungen durch die Kombination von Python-Skripten mit reaktiven Webtechnologien zu erstellen. (\cite{Dabbas2021}) zeichnet sich Dash durch seine Fähigkeit aus, interaktive Dashboards zu erstellen, die direkt mit Datenquellen verbunden sind und eine Echtzeit-Aktualisierung der Daten ermöglichen.\\[1em] Das Framework basiert auf drei Haupttechnologien: Flask, React.js und Plotly.js. Flask fungiert als leichtgewichtiges Web-Framework, das die serverseitige Logik und die Anbindung an Datenquellen übernimmt. React.js, eine JavaScript-Bibliothek für die Entwicklung von Benutzeroberflächen, ermöglicht die Erstellung dynamischer und reaktiver UI-Komponenten. Plotly.js, die Visualisierungsbibliothek, bietet leistungsstarke Tools zur Erstellung interaktiver und ansprechender Diagramme und Graphen.\\[1em] Die Modularität von Dash ist ein entscheidender Vorteil, der es Entwicklern erlaubt, verschiedene Komponenten wie Diagramme, Slider und Dropdown-Menüs zu kombinieren und anzupassen. Diese Flexibilität macht Dash besonders geeignet für Anwendungen im Bereich der Datenanalyse, wo unterschiedliche Visualisierungstypen oft in einem einzigen Dashboard zusammengeführt werden müssen (\cite{Dabbas2021}).

\subsection{Vue.js und Nuxt.js}
Vue.js ist ein progressives JavaScript-Framework, das durch seine Reaktivität und Modularität besticht. In der wissenschaftlichen Literatur wird Vue.js häufig als ein Framework hervorgehoben, das sich durch seine Lernfreundlichkeit und die Fähigkeit zur schrittweisen Integration in bestehende Projekte auszeichnet (\cite{Li2021}). Laut (\cite{Novac2021}) ist Vue.js besonders geeignet für die Entwicklung von Single-Page Applications (SPAs), bei denen eine hohe Interaktivität der Benutzeroberfläche gefordert ist. \\[1em] Nuxt.js erweitert Vue.js um Funktionen wie serverseitiges Rendering (SSR) und statische Seitengenerierung, die besonders für die Entwicklung von performanten und SEO-freundlichen Webanwendungen wichtig sind (\cite{Gomes2023}). SSR ist in der Lage, die Ladezeiten von Seiten zu reduzieren und die Benutzererfahrung zu verbessern, was besonders in datenintensiven Anwendungen von Bedeutung ist (\cite{Sianandar2022}).

\subsection{Tailwind CSS}
Tailwind CSS ist ein Utility-first CSS-Framework, das in der Webentwicklung zunehmend an Bedeutung gewinnt. Laut (\cite{Rifandi2022}) erlaubt es Tailwind CSS, schnell prototypische Benutzeroberflächen zu erstellen, indem es eine grosse Anzahl von vorgefertigten CSS-Klassen bereitstellt. Diese Klassen sind darauf ausgelegt, ohne zusätzliche Anpassungen direkt im HTML-Code verwendet zu werden, was den Entwicklungsprozess beschleunigt und eine konsistente Gestaltung der Benutzeroberfläche gewährleistet (\cite{Rifandi2022}).\\[1em] In wissenschaftlichen Untersuchungen wird hervorgehoben, dass Utility-first-Ansätze wie Tailwind CSS eine höhere Flexibilität und Wiederverwendbarkeit von Code bieten, da sie Entwicklern ermöglichen, ohne Abhängigkeit von spezifischen Designsystemen oder vorgefertigten Komponenten zu arbeiten (\cite{Wang2023}).

\subsection{Python Flask}
Flask ist ein mikroframework für Python, das sich durch seine Einfachheit und Flexibilität auszeichnet. Es wurde erstmals von (\cite{Relan2019}) beschrieben und hat sich seitdem als beliebte Wahl für die Entwicklung von Webanwendungen etabliert, insbesondere in Projekten, die eine schnelle und unkomplizierte Implementierung erfordern. Flask bietet grundlegende Funktionalitäten wie Routing und Vorlagen-Rendering, die durch eine Vielzahl von Erweiterungen an die spezifischen Bedürfnisse eines Projekts angepasst werden können (\cite{Chauhan2019}).\\[1em]Flask wird in vielen wissenschaftlichen Arbeiten als Beispiel für ein Framework hervorgehoben, das eine Balance zwischen Leichtigkeit und Erweiterbarkeit bietet, was es ideal für kleine bis mittelgrosse Webprojekte macht (\cite{PAZDRIY2023}). In deinem Projekt dient Flask als Backend-Framework, das die Kommunikation zwischen dem Frontend und den Datenquellen ermöglicht, eine entscheidende Rolle bei der Integration von Datenverarbeitungsroutinen spielt und eine stabile Grundlage für die Anwendungslogik bietet.

\subsection{Datenvisualisierung und Benutzerfreundlichkeit}
Datenvisualisierung ist ein wesentlicher Bestandteil der Datenanalyse, der es ermöglicht, komplexe Datensätze in eine visuelle Form zu überführen, die leicht verständlich und interpretierbar ist. (\cite{Nair2018}) betont, dass die Qualität der Visualisierung einen direkten Einfluss auf die Fähigkeit der Benutzer hat, aus den dargestellten Daten sinnvolle Erkenntnisse zu gewinnen.\\[1em]Benutzerfreundlichkeit ist ein weiterer kritischer Faktor bei der Entwicklung von Dashboards. Laut (\cite{Desai2016}) bestimmt die Benutzerfreundlichkeit, wie effektiv, effizient und zufriedenstellend eine Softwarelösung ist. In der Dashboard-Entwicklung bedeutet dies, dass die Visualisierungen intuitiv bedienbar sein müssen und die Interaktionen so gestaltet sein sollten, dass sie die analytische Arbeit des Benutzers unterstützen und nicht behindern.\\[1em]Die Optimierung der Benutzeroberfläche und die Auswahl geeigneter Visualisierungstypen sind daher zentrale Herausforderungen, die durch eine Kombination von wissenschaftlichen Methoden und modernen technologischen Werkzeugen angegangen werden müssen (\cite{Saket2019}).
\newpage
	\section{Stand der Forschung}
	\label{sec:standDerForschung}

\subsection{Entwicklung von Dashboards in der Datenvisualisierung}
Die Rolle von Dashboards in der Datenvisualisierung hat sich in den letzten Jahren erheblich weiterentwickelt. Ursprünglich wurden Dashboards vor allem als statische Berichtsplattformen genutzt, doch mit dem Aufkommen neuer Webtechnologien haben sich die Anforderungen an Dashboards stark verändert. Laut (\cite) dienen moderne Dashboards nicht nur der Visualisierung von Daten, sondern auch der Interaktion mit diesen. Dadurch ermöglichen sie eine tiefere Analyse und ein besseres Verständnis der zugrunde liegenden Daten.\\[1em] Aktuelle Studien zeigen, dass die Effektivität von Dashboards stark von ihrer Fähigkeit abhängt, grosse und komplexe Datensätze in Echtzeit darzustellen und dem Benutzer intuitive Werkzeuge zur Verfügung zu stellen, um diese Daten zu manipulieren (\cite). Die Entwicklung solcher Dashboards erfordert daher nicht nur ein tiefes Verständnis der Benutzeranforderungen, sondern auch die Fähigkeit, leistungsstarke Visualisierungs- und Interaktionsmechanismen zu implementieren.

\subsection{Einsatz moderner Frontend-Technologien}
Moderne Frontend-Technologien wie Vue.js und Nuxt.js spielen eine entscheidende Rolle bei der Entwicklung interaktiver Dashboards. Diese Technologien ermöglichen es Entwicklern, modulare und reaktive Benutzeroberflächen zu erstellen, die sich dynamisch an veränderte Daten und Benutzerinteraktionen anpassen. Laut (\cite) hat Vue.js in den letzten Jahren erheblich an Popularität gewonnen, vor allem aufgrund seiner einfachen Integration und der Möglichkeit, komplexe Anwendungen mit minimalem Aufwand zu entwickeln.\\[1em] Ein weiterer wichtiger Aspekt ist die serverseitige Rendering-Funktionalität von Nuxt.js, die besonders für Anwendungen mit hohem Datenaufkommen und der Notwendigkeit einer schnellen Ladezeit von Bedeutung ist (\cite). Durch das serverseitige Rendering wird der initiale Ladevorgang der Seite beschleunigt, was die Benutzererfahrung erheblich verbessert.
\newpage

\subsection{Modularität und Dynamik in Dashboards}
Die Modularität von Dashboards ist ein Thema, das in der wissenschaftlichen Literatur ausführlich diskutiert wird. Ein modulares Dashboard-Design ermöglicht es, einzelne Komponenten unabhängig voneinander zu entwickeln, zu testen und zu aktualisieren, was die Wartbarkeit und Skalierbarkeit der Anwendung erheblich verbessert (\cite). Dies ist besonders wichtig in Umgebungen, in denen Dashboards ständig aktualisiert werden müssen, um neuen Anforderungen gerecht zu werden.\\[1em]Die Dynamik von Dashboards bezieht sich auf ihre Fähigkeit, auf Benutzerinteraktionen in Echtzeit zu reagieren. Laut (\cite) ist die Fähigkeit zur dynamischen Anpassung von Datenansichten ein Schlüsselfaktor für die Benutzerfreundlichkeit von Dashboards. Dies erfordert nicht nur fortschrittliche Frontend-Technologien, sondern auch eine effiziente Backend-Architektur, die schnelle Datenabrufe und -verarbeitungen ermöglicht.

\subsection{Datenvisualisierung und Benutzerfreundlichkeit}
Die Benutzerfreundlichkeit von Dashboards ist ein weiteres zentrales Forschungsgebiet. Studien haben gezeigt, dass die Benutzerfreundlichkeit von Dashboards stark von der Qualität und Klarheit der Visualisierungen abhängt (\cite). Die Auswahl der richtigen Visualisierungstypen und deren effektive Darstellung sind entscheidend, um den Benutzern zu helfen, komplexe Daten zu verstehen und fundierte Entscheidungen zu treffen.\\[1em]Ein weiteres wichtiges Kriterium ist die Interaktivität der Visualisierungen. Benutzer sollten in der Lage sein, durch einfache Aktionen wie Klicken, Zoomen oder Filtern tiefere Einblicke in die Daten zu gewinnen (\cite). Dies stellt hohe Anforderungen an das Design und die Implementierung der Benutzeroberfläche, insbesondere wenn es darum geht, eine Balance zwischen Funktionalität und Einfachheit zu finden.

\subsection{Aktuelle Herausforderungen und zukünftige Entwicklungen}
Trotz der Fortschritte in der Dashboard-Entwicklung stehen Entwickler nach wie vor einer Reihe von Herausforderungen. Eine der grössten Herausforderungen ist die Integration von grossen, heterogenen Datenquellen in ein einziges, kohärentes Dashboard. Die Skalierbarkeit und Performance solcher Systeme sind oft begrenzt, insbesondere wenn Dashboards in Echtzeit aktualisiert werden müssen (\cite).\newpage Zukünftige Entwicklungen in diesem Bereich könnten durch den verstärkten Einsatz von Künstlicher Intelligenz und maschinellem Lernen vorangetrieben werden, die dazu beitragen könnten, die Datenanalyse zu automatisieren und die Benutzer bei der Interpretation der Ergebnisse zu unterstützen (\cite). Ein weiteres Forschungsfeld ist die Verbesserung der Benutzerfreundlichkeit durch den Einsatz von natürlichen Sprachverarbeitungstechnologien, die es Benutzern ermöglichen, Dashboards durch sprachliche Anfragen zu steuern.
\newpage
	\section{Methodik}
	\label{sec:standDerForschung}

{\subsection{Projektübersicht}}

Das Projekt \textit{DashyBuilder} wurde als Prototyp entwickelt, um die Forschungsfrage zu untersuchen, wie moderne Frontend-Technologien zur Entwicklung eines dynamischen und modularen Dashboard-Layouts eingesetzt werden können, um die Benutzerfreundlichkeit und Wartbarkeit zu maximieren. Dieser Prototyp konzentriert sich darauf, grundlegende, aber essenzielle Funktionen zu demonstrieren, die in einem Dashboard notwendig sind, wobei ein klarer Fokus auf Modularität, Flexibilität und Erweiterbarkeit gelegt wurde.

\subsection{Entscheidung für das CSV-Dateiformat}
Die Entscheidung, ausschließlich das CSV-Dateiformat (Comma-Separated Values) für den Datenimport zu verwenden, basiert auf der weit verbreiteten Nutzung und Standardisierung dieses Formats. CSV-Dateien sind eines der am häufigsten verwendeten Formate für den Datenaustausch, insbesondere in den Bereichen Datenanalyse und Datenverarbeitung. Sie bieten eine plattformunabhängige Möglichkeit, Daten in einer textbasierten, leicht zugänglichen Form zu speichern, die von nahezu allen Datenverarbeitungstools unterstützt wird. Laut Yau (2013) gehört das CSV-Format zu den am häufigsten verwendeten Formaten in der Datenwissenschaft, da es einfach zu handhaben und weitgehend kompatibel ist. Diese Eigenschaften machen CSV-Dateien ideal für den Einsatz in einem Prototypen wie DashyBuilder, der darauf abzielt, grundlegende Funktionalitäten schnell und effektiv zu demonstrieren. Die einfache Struktur von CSV-Dateien erleichtert zudem die Implementierung und Validierung von Datenverarbeitungsroutinen, was für die schnelle Entwicklung eines Prototyps entscheidend ist (\cite). Darüber hinaus bleibt die Möglichkeit bestehen, das System später zu erweitern, um weitere Dateiformate zu unterstützen, falls die Anforderungen dies erfordern.

\subsection{Auswahl der Widget-Typen}
Im Rahmen von DashyBuilder wurde entschieden, sich auf vier zentrale Widget-Typen zu konzentrieren: Chart, Table, Filter Box und Text Block. Diese Auswahl basiert auf einer umfassenden Analyse der häufigsten Elemente in Dashboards und den grundlegenden Anforderungen an eine effektive Datenvisualisierung. Diagramme (Charts) sind unverzichtbar für die Darstellung von Trends und Mustern in Daten, da sie es ermöglichen, schnell fundierte Entscheidungen zu treffen (\cite). Tabellen (Tables) dienen der übersichtlichen Darstellung grosser Datenmengen und sind somit besonders wichtig für detaillierte Analysen (Few, 2006). Filterboxen (Filter Boxes) bieten interaktive Möglichkeiten, spezifische Daten auszuwählen und fokussierte Analysen durchzuführen, während Textblöcke (Text Blocks) wichtige Informationen und Erklärungen direkt im Dashboard präsentieren, um die Verständlichkeit und Benutzerführung zu unterstützen (\cite). Die Konzentration auf diese vier Typen ermöglichte es, einen funktionalen Prototyp zu entwickeln, der die wesentlichen Anforderungen eines modernen Dashboards erfüllt. Da DashyBuilder als Prototyp konzipiert wurde, lag der Fokus auf der Reduktion der Komplexität, um den Entwicklungsprozess zu beschleunigen und die Forschungsfrage effizient zu beantworten. Gleichzeitig bleibt das System offen für zukünftige Erweiterungen, um weitere Widgets zu integrieren, sobald zusätzliche Anforderungen identifiziert werden.

\subsection{Implementierung des Frontends}
Das Frontend von DashyBuilder wurde mit Nuxt.js entwickelt, einem Framework, das auf Vue.js basiert und zusätzliche Funktionen wie serverseitiges Rendering und statische Seitengenerierung bietet. Nuxt.js wurde gewählt, weil es eine modulare Architektur bietet, die es ermöglicht, wiederverwendbare Komponenten zu erstellen und das Frontend effizient zu skalieren \cite[S.119]{Dibia2023}). Die Seitenstruktur umfasst verschiedene Hauptkomponenten, die die Kernfunktionen des Dashboards abdecken. Besonders hervorzuheben ist die Verwendung eines Grid-Layouts zur Anordnung der Widgets, das eine flexible und anpassbare Benutzeroberfläche ermöglicht. Durch die Implementierung dynamischer Routen und modularer Komponenten kann das Dashboard flexibel auf die unterschiedlichen Anforderungen der Benutzer reagieren, was die Benutzerfreundlichkeit und Wartbarkeit des Systems erheblich steigert.

\subsection{Implementierung des Backends}
Die Implementierung des Backends in DashyBuilder basiert auf Flask, einem leichtgewichtigen Web-Framework für Python, das sich durch seine Flexibilität und einfache Handhabung auszeichnet \cite[S.119]{Dibia2023}). Die zentrale Konfiguration der Anwendung, die in der Datei config.py definiert ist, stellt sicher, dass alle notwendigen Verzeichnisse, wie das Upload-Verzeichnis für CSV-Dateien, vorhanden sind und korrekt konfiguriert werden. Diese Konfiguration erleichtert die Verwaltung und Erweiterung der Anwendung, indem sie eine einheitliche und gut strukturierte Grundlage für die gesamte Backend-Logik bietet. Ein wesentlicher Bestandteil von DashyBuilder ist die dynamische Generierung von Dashboards, die es den Benutzern ermöglicht, ihre eigenen Dashboards zu erstellen, indem sie Widgets hinzufügen, anpassen und deren Position im Grid-Layout bestimmen. Diese Funktion wird durch den Code in dashboard.py realisiert, der das Layout und die Funktionsweise der Widgets in der Dash-Anwendung definiert. Die dynamische Generierung stellt sicher, dass das Dashboard flexibel und anpassbar bleibt, was besonders in Anwendungsbereichen mit wechselnden Anforderungen und sich schnell ändernden Daten von grossem Nutzen ist.

\subsection{Datenverarbeitung und Upload-Management}
Die Verwaltung von Datenuploads erfolgt in DashyBuilder über das Modul uploader.py, das speziell dafür entwickelt wurde, grosse Datensätze effizient zu verarbeiten. Der Upload-Mechanismus unterstützt das Hochladen in kleinen Chunks, was die Verarbeitung grosser Dateien ermöglicht, ohne dass es zu Speicherproblemen kommt. Nach dem Upload werden die Daten nahtlos in das Dashboard integriert, wo sie analysiert und visualisiert werden können. Diese Architektur gewährleistet eine hohe Leistungsfähigkeit und Stabilität des Systems, selbst bei der Verarbeitung umfangreicher Datenmengen \cite[S.119]{Dibia2023}). Durch die Implementierung eines effizienten Upload- und Datenverarbeitungssystems wird sichergestellt, dass das Dashboard auch bei umfangreichen Datenanforderungen reaktionsschnell und zuverlässig bleibt.

\subsection{Zusammenfassung}
Die Entwicklung von DashyBuilder legt den Grundstein für ein modulares und flexibles Dashboard-System, das bereits in seiner prototypischen Form die wichtigsten Anforderungen an ein modernes Dashboard erfüllt. Die getroffenen Entscheidungen hinsichtlich der Auswahl der Datenformate und Widget-Typen sind wissenschaftlich fundiert und ermöglichen es, den Prototypen bei Bedarf problemlos zu erweitern und anzupassen. Mit DashyBuilder wurde eine Grundlage geschaffen, die sowohl für den unmittelbaren Einsatz als auch für die zukünftige Weiterentwicklung geeignet ist, um den Anforderungen moderner Datenvisualisierungs- und Analysewerkzeuge gerecht zu werden.


 

		
    
%\end{landscape}
\intextsep 5pt




%Literaturverzeichnis
%------------------------------------------------------------
%Verwendete Literatur
\newpage
\pagenumbering{Roman}
\setcounter{page}{4}
%\setlength{\bibitemsep}{2\itemsep} %Abstand zwischen den Einträgen im Literaturverzeichnis
\printbibliography[heading=bibnumbered, title={Verwendete Literatur}, keyword=verwendet] % Erstellen des Literaturverzeichnisses nur unter Berücksichtigung der Quelleneinträge mit de keyword "verwendet" das keyword ist manuell einzufügen.

%Weiterführende Literatur
\newpage
\nocite{*} % Setzt alle Einträge in der .bib Datei als "zitiert"
\printbibliography[heading=bibnumbered, title={Weiterführende Literatur}, notkeyword=verwendet] % schreibt alle Quellen ins Verzeichnis, die nicht über das keyword "verwendet" verfügen. 
%\printbibliography[heading=subbibnumbered, title={Weiterführende Literatur}, keyword=verwendet]





%------------------------------------------------------------


%Glossar
%------------------------------------------------------------
%\newpage
%------------------------------------------------------------

%pdf einfügen
%--------------------------------------------------------------
\includepdf[pages={1}]{eigenstandigkeitserklarung.pdf}


%--------------------------------------------------------------


	%\end{flushleft}


\end{document}